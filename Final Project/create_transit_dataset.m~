% Processes photometric data to add transit data to the star_data dataset.
function create_transit_dataset()
    % Load star dataset
    in.data = readtable('./data/star_data.csv');
    % Load Transit Period Table
    transitPeriods = readtable(char("./data/transit_periods.csv"));

    % Constants:
    Rsol = 695510e3; % [m] Radius of the Sun
    REarth = 6371e3; % [m] Radius of the Earth
    
    % Input Data Column Indices:
    in.class = 1;
    in.TICID = 2;
    in.mag = 3;
    in.Teff = 4; % [K]
    in.Rstar = 5; % [Rsol]
    in.Lstar = 6; % [Lsol]

    % Light Curve Features:
    N_peaks = zeros(height(in.data),1); % Number of Flux Histogram Peaks for Each Light Curve
    peakSep = zeros(height(in.data),1); % Mean Peak Separatation in Flux Histogram for Each Light Curve
    
    % Transit Features:
    PPPeriod = zeros(height(in.data),1); % Peak Power Period of Object
    transitDepth = zeros(height(in.data),1); % [PPM] Max Depth of Transit Event
    transitDuration = zeros(height(in.data),1); % [days] Full Duration of Transit Event
    transitEdgeTime = zeros(height(in.data),1); % [days] Time planet spends crossing the edge of the star. Average of Rise Time and Fall Time of Transit Event.
    planetRadius = zeros(height(in.data),1); % [REarth] Predicted Planet Radius
    
    validObjects = false(height(in.data),1); % Boolean List of All TIC Objects for which All Analysis could be Performed (all data valid).
    timer = tic;
    
    for i = 1:height(in.data)
        TIC = in.data{i,in.TICID};

        if ~mod(i,10)
            DT = toc(timer);
            disp("Reading Light Curve " + i + " for TIC " + TIC);
            if i > 1
                ETA = (height(in.data)-i) * DT / (i-1);
                disp("Time Elapsed: " + floor(DT/60) + "min, ETA: " + ceil(ETA/60) + "min");
            end
        end

        valid = true;
        %% Light Curve Analysis
        % Grab Light Curve:
        try
            curve = readtable(char("./light_curves/lc_"+TIC+".csv"));
        catch e
            valid = false;
            disp("No Valid Light Curve at i="+i+" for TIC="+TIC);
            warning(e.message);
        end
        % Analyze Light Curve:
        if valid
            % Find most common collections of fluxes:
            [N,flux_bins] = hist(curve.flux);
            [~,flux_clumps] = findpeaks(N,flux_bins);
            N_peaks(i) = length(flux_clumps);
            sep = mean(diff(flux_clumps));
            if isnan(sep)
                peakSep(i) = 0;
            else
                %% TODO: Precalc F0, (and DF?) before descent.
                peakSep(i) = 1e6 * sep / max(flux_clumps);
            end
        end
        
        %% Periodogram Results (peak power period)
        % Find Transit Period (if in table and TIC hasn't been invalidated yet):
        if valid
            period = transitPeriods(transitPeriods.TICID == TIC, :).Period;
            if numel(period) > 0
                PPPeriod(i) = string(period{1});
            else
                valid = false; % Period not in table (periodogram couldn't be built)
            end
        end
        
        %% Folded Transit Curve Analysis
        % Grab Folded Transit Curve:
        if valid
            try
                transit = readtable(char("./transits/tr_"+TIC+".csv"));
            catch e
                valid = false;
                disp("No Valid Folded Transit Curve at i="+i+" for TIC="+TIC);
                warning(e.message);
            end
        end
        
        if valid
            % Compute Depth:
            % Bin Fluxes (TODO: Remove this once binsize in photometry collector is fixed).
            binned_flux = smooth(transit.flux, floor(numel(transit.flux)/25), 'moving');
            binned_time = transit.time; % Eventually, there could be a dimensionally reduction associated with smoothing which will make this necessary.

            % Find most common collections of fluxes in folded transit curve:
            [N,flux_bins] = hist(binned_flux);
            [~,flux_clumps] = findpeaks(N,flux_bins);
            % Include edge "peaks" if applicable (particularly the max, since this is likely the
            % baseline):
            if N(end) > N(end-1)
                flux_clumps(end+1) = flux_bins(end);
            end
            if N(1) > N(2)
                flux_clumps(end+1) = flux_bins(1);
            end

            % Nominal (baseline) Flux:
            tr_base = max(flux_clumps);
            % Maximum Transit Depth:
            tr_min = min(flux_clumps);

            % Transit Depth:
             depthRatio = (tr_base - tr_min) / tr_base;
             transitDepth(i) = 1e6 * depthRatio;

            if depthRatio ~= 0 % Significant transit observed
             % Compute Timing:
                % Find time of first and last point below 50% depth:
                idx_50 = find(binned_flux < (tr_base + 0.5*(tr_min-tr_base))); % Index of all points below 50% transit depth
                t_50drop = transit.time(idx_50(1)); % Time when first transit drops below 50%
                t_50rise = transit.time(idx_50(end)); % Time when transit rises above 50% for last time
                % Find time of first point beyond 100% depth:
                idx_100 = find(binned_flux < (tr_base + 1.0*(tr_min-tr_base))); % Index of all points below 100% transit depth
                t_100drop = transit.time(idx_100(1)); % Time when first transit drops below 100%
                t_100rise = transit.time(idx_100(end)); % Time when transit rises above 100% for last time
                % Compute 50%->100% "Edge" Time:
                t_fall = t_100drop - t_50drop; 
                t_rise = t_50rise - t_100rise;
                transitEdgeTime(i) = 2*mean([t_fall, t_rise]);
                transitDuration(i) = (t_50rise - t_50drop) + transitEdgeTime(i);
                
            % Compute Planet Parameters:
                planetRadius(i) = in.data.StarRadius(find(in.data.TIC_ID == TIC,1)) * sqrt(depthRatio) * REarth/Rsol;
            end
        end
        
        % Mark Validity:
        validObjects(i) = valid;
    end

    % Trim data from invalid objects:
    N_peaks = N_peaks(validObjects);
    PPPeriod = PPPeriod(validObjects);
    transitDepth = transitDepth(validObjects);
    transitDuration = transitDuration(validObjects);
    transitEdgeTime = transitEdgeTime(validObjects);
    planetRadius = planetRadius(validObjects);

    %% Create New Dataset:
    % Columns of Output Table (name of fields following structs,
    % 'class' must be first and is not present in structs):
    columns = {'class', 'TICID', 'mag', 'Teff', 'Rstar', 'Lstar', 'Npeaks', 'PPPeriod','Depth','t_trans','t_edge', 'Rp'};
    columnDesc = {'class', 'TIC_ID', 'TESSMagnitude', 'StarTemp', 'StarRadius', 'StarLuminosity', 'NFluxRegions', 'PPPeriod','TransitDepth','TransitDuration','TransitEdgeTime', 'PlanetRadius'}; % human-readable headers for output table
    %columns = {'class', 'TICID', 'mag', 'Teff', 'Rstar', 'Lstar', 'fit', 'depth', 'period', 'number', 'duration', 'riseTime'};
    %columnDesc = {'class', 'TIC_ID', 'TESSMagnitude', 'StarTemp', 'StarRadius', 'StarLuminosity', 'FitRSquared', 'DepthPPM', 'Period', 'Number', 'Duration', 'RiseTime'}; % human-readable headers for output table

    out.data = table;
    out.data{:,:} = in.data{validObjects,:}; % copy over valid entries
    out.data{:,end+1:end+5} = [N_peaks, ];

    % Export Dataset:
    out.data.Properties.VariableNames = columnDesc; % Label Table
    writetable(out.data, './data/data_with_transits.csv');
end
